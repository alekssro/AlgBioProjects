---
title: "Project 2"
author: "Alejandro Roca Arroyo and Emil Maag"
date: "September 18, 2018"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, comment = NA)
```


```{r, echo=FALSE,message=FALSE}
library(tidyverse)
# library(readxl)
```

# Introduction

In this project we implemented and experimented with the exact (dynamic programming based) and the 2-approximation algorithm for global sum-of-pairs multiple alignment. We wrote two programs: `msa_exact.py` that implements the exact algorithm for computing an optimal MSA of 3 sequences and its score (decribed on page 408 in BA, or in Section 14.6.1 in Gusfield's book), and `msa_approx.py` that implements the 2-approximation algorithm for any number of sequences (described in Section 8.2.2 in BA, or in Section 14.6.2 in Gusfield's book). Both programs use classes contained in `Alignment.py`.
 
# Methods 

We defined classes for the data in the exercise with the methods we needed, in order to access them easily.

The following example shows how to use the programs from the command line:   

`./msa_exact.py score_matrix gapcost file_with_sequences.fasta`
`./msa_approx.py score_matrix gapcost file_with_sequences.fasta`

The followng list describes the arguments in more detail:

Arguments:

 - score_matrix: file containing the score matrix used for the alignment. In a "Phylip-like" format.
 
 - gapcost: a number corresponding to the desired gap cost value.
     
 - file_with_sequences.fasta: a fasta file containing multiple sequences that will be aligned.

The file with sequence in fasta format (file_with_sequences.fasta) as well as the score_matrix file and the library containing the appropriate methods (Alignment.py) have to be located in the same folder as the programs for execution.  

#### Code remarks

The key in this project was to find the way to extend the multiple alignment matrix (M), as the rest of the methods don't differ much from what we have talked about in class. This algorithm was implemented in the following way:

```{python eval=F}
def extendM(self, optAlign):

    if not self.M:  # empty alignment matrix (first time we call the matrix)
        self.M = optAlign   # first optimal alignment = M (initialize)
        return

    i = 0
    while self.M[0] != optAlign[0]: 
        # The first element of the alignment matrix and the one in the optimal 
        # alignment should be the same in the last iteration
        if i < len(self.M[0]):  # avoid index out of range (see elif)

            if self.M[0][i] == "-": # finds a gap in the center string (0) in the alignment (M)
                optAlign[0] = optAlign[0][:i] + '-' + optAlign[0][i:]   # add gap in optAlign at position i
                optAlign[1] = optAlign[1][:i] + '-' + optAlign[1][i:]   # add gap in optAlign at position i
            elif optAlign[0][i] == "-": # finds a gap in the center string in the optimal alignment
                for j in range(len(self.M)):
                    self.M[j] = self.M[j][:i] + "-" + self.M[j][i:] # add gap in all the sequences of the M alignment 

        elif optAlign[0][i] == "-": 
            # finds a gap at the end of the OptAlign, meaning optAlign length > M[j]
            for j in range(len(self.M)):
                self.M[j] = self.M[j][:i] + "-" + self.M[j][i:] # add gap in all the sequences of the M alignment
        
        i += 1

    self.M.append(optAlign[1])  # add new aligned sequence once all changes are done
```

As explained in the code, if it is the first time we run the code, we assign the optimal alignment to the M matrix (which contains the aligned sequences). In the following runs, we will iterate until the changes made in the center sequence both in M and in the optimal alignment, make them the same sequences (meaning we are ready to add the new sequence, second element of the optimal alignment). We then iterate through all the positions in the sequences and,

- if we find a gap in the ith position of the first sequence of the M (center string), we need to add a gap in both sequences of the optimal alignment, at position i.

- if we find a gap in the ith position of the first sequence of the optimal alignment (center string pairwise-aligned), we need to add a gap in all sequences of the multiple alignment matrix, at position i.

After one or none of these conditions are met, we check the next position in the sequences (increase i). If the i is higher than the length of the sequences of the multiple alignment matrix M, meaning the optimal alignment length is higher, we will see a gap in the last position of the center string pairwise-aligned. We again add a gap to all the sequences in the M matrix, at last position.

### Tests

To verify the correctness of our programs, we were given two fasta files (`testdata_short.txt` and `testdata_long.txt`) from which we know their expected multiple alignment score. We run our programs and check if the score matches the expected (for the exact approach it should be the same and for the approximate approach it should be equal or higher)

#### Using exact approach

```{bash echo=F}
echo "Expected alignment score of sequences in testdata_short.txt: 198"
echo "Obtained result:"
./msa_exact.py score_matrix 5 testdata_short.txt > testdata_short_aligned.fa
python3 msa_sp_score_3k.py testdata_short_aligned.fa
```
\   
```{bash echo=F}
echo "Expected alignment score of sequences in testdata_long.txt: 1482"
echo "Obtained result:"
./msa_exact.py score_matrix 5 testdata_long.txt > testdata_long_aligned.fa
python3 msa_sp_score_3k.py testdata_long_aligned.fa
```

#### Using approximate approach

```{bash echo=F}
echo "Expected alignment score of sequences in testdata_short.txt: >=198"
echo "Obtained result:"
./msa_approx.py score_matrix 5 testdata_short.txt > testdata_short_aligned.fa     # Get alignment
python3 msa_sp_score_3k.py testdata_short_aligned.fa     # Compute score
```
\   
```{bash echo=F}
echo "Expected alignment score of sequences in testdata_long.txt: >= 1482"
echo "Obtained result:"
./msa_approx.py score_matrix 5 testdata_long.txt > testdata_long_aligned.fa     # Get alignment
python3 msa_sp_score_3k.py testdata_long_aligned.fa     # Compute score

# Clean generated files
rm testdata_short_aligned.fa testdata_long_aligned.fa
```

# Experiments

In the experiments section we were asked to answer the following questions:

### What is the score of an optimal aligment of the first 3 sequences in brca1-testseqs.fasta (i.e. brca1_bos_taurus, brca1_canis_lupus and brca1_gallus_gallus) as computed by your program sp_exact_3? How does an optimal alignment look like?

To answer this question we extracted the first 3 sequences into a new fasta file and run our exact multiple sequence alignment (MSA) implementation on this file. Generated files are deleted after at the end.

```{bash echo=F}
head -n 12 brca1-testseqs.fasta > brca1-first3.fasta
echo "Score of an optimal aligment of the first 3 sequences in brca1-testseqs.fasta, using an exact approach:"
./msa_exact.py score_matrix 5 brca1-first3.fasta > brca1-first3_aligned.fa      # Get alignment
python3 msa_sp_score_3k.py brca1-first3_aligned.fa      # Calculate score
echo ""
echo "Optimal alignment:"
cat brca1-first3_aligned.fa     # Print alignment

# Clean generated files
rm brca1-first3_aligned.fa brca1-first3.fasta
```

### What is the score of the alignment of the first 5 sequences in  brca1-testseqs.fasta (i.e. brca1_bos_taurus, brca1_canis_lupus, brca1_gallus_gallus, brca1_homo_sapiens, and brca1_macaca_mulatta) as computed by your program sp_approx?

Again we extract the first 5 sequences and this time we use the approximate implementation for the MSA. Generated files are deleted at the end.

```{bash echo=F}
head -n 20 brca1-testseqs.fasta > brca1-first5.fasta
echo "Score of an optimal aligment of the first 5 sequences in brca1-testseqs.fasta, using an approximate approach:"
./msa_approx.py score_matrix 5 brca1-first5.fasta > brca1-first5_aligned.fa
python3 msa_sp_score_3k.py brca1-first5_aligned.fa
echo ""
echo "Optimal alignment:"
cat brca1-first5_aligned.fa
```

### Which of the 5 sequences is choosen as the 'center string'?

The center string is placed in the top position in the alignment in our implementation, therefore, center string:

```{bash}
head -n 1 brca1-first5_aligned.fa

# Clean generated files
rm brca1-first5_aligned.fa brca1-first5.fasta
```


Make an experiment comparing the scores of the alignments computed by sp_exact_3 and sp_approx that validates that the approximation ratio of sp_approx is 2(k-1)/k for k sequences. i.e 4/3 for three sequences.

You should use the testdata in  testseqs.zip

that contains 20 fasta files (testseqs_10_3.fasta, testseqs_20_3.fasta, ..., testseqs_200_3.fasta) each containing 3 sequences of lengths 10, 20, ..., 200.
For each triplet of sequences (i.e. each fasta file), you should compute the optimal score of an MSA using sp_exact_3 and the score of the alignment produced by sp_approx. Make a graph in which you plot the ratio of the computed scores for each sequence length. Comment on what you observe.

### Evaluation cases for global alignment usign linear and affine gap cost.

All questions are answered by showing the program used in the command line and the answers the program gave. 

For question 3 and 4 a bash program were written to produce the desired matrices. 


Question 1
----------

Compute the score of an optimal alignment and an optimal alignment of
seq1 and seq2 above using the programs global_linear using the above
score matrix M and gap cost g(k)=5*k.

Answers:

```{bash, eval=T}
./global_alignment.py sequences/seq1.fasta sequences/seq2.fasta score_matrix -l 5
```

```{bash, eval=T}
./global_alignment.py sequences/seq1.fasta sequences/seq2.fasta score_matrix -l 5 -o
```

optimal alignment:

>seq1

TATGGA-GAGAATAAAAGAACTGAGAGATCT-AATGTCGCAGTCCCGCAC-TC

GCGAGATACT-CACTAAGAC-CACTGTGGACCATATGGCCATAATCAAAAAG

>seq2

A-TGGATGTCAATCCGA-CTCTACTTTTCCTAAAAATTCCAGCGCAAAATGCC

ATAAG-CACCACATTCCCTTATACTGGAGATCCT-CCA-TACAGCCATGGAA


Question 2
----------

Compute the score of an optimal alignment and an optimal alignment of
seq1 and seq2 above using the program global_affine using the above
score matrix M and gap cost g(k)=5+5*k.

Answers:

```{bash, eval=T}
./global_alignment.py sequences/seq1.fasta sequences/seq2.fasta score_matrix -a 5 5
```

optimal alignment score: 269.0

```{bash, eval=T}
./global_alignment.py sequences/seq1.fasta sequences/seq2.fasta score_matrix -a 5 5 -o
```

optimal alignment:

>seq1

TATGGAGAGAATAAAAGAACTGAGAGATCT-AATGTCGCAGTCCCGCAC-TCG

CGAGATACTCACTAAGAC-CACTGTGGACCATATGGCCATAATCAAAAAG

>seq2

ATGGATGTCAATCCGA-CTCTACTTTTCCTAAAAATTCCAGCGCAAAATGCCA

TAAGCACCACATTCCCTTATACTGGAGATCCT-CCA-TACAGCCATGGAA



Question 3
----------

Compute the optimal score of an optimal alignment for each pair of the
5 sequences above using global_linear with the score matrix M and gap
cost g(k)=5*k. The result is a 5x5 table where entry (i,j) the optimal
score of an alignment of seqi and seqj.

Answer:

```{bash eval=F}
./evaluate_global_alignment.sh 0 5
```

0 231.0 206.0 202.0 214.0

226.0 0 239.0 223.0 220.0

206.0 242.0 0 219.0 205.0

202.0 223.0 219.0 0 210.0

209.0 220.0 205.0 210.0 0 

Question 4
----------

Compute the optimal score of an optimal alignment for each pair of the
5 sequences above using global_affine with the score matrix M and gap
cost g(k)=5+5*k. The result is a 5x5 table where entry (i,j) the
optimal score of an alignment of seqi and seqj.

Answer:

```{bash eval=F}
./evaluate_global_alignment.sh 5 5
```

0 269.0 242.0 243.0 261.0

266.0 0 283.0 259.0 254.0

242.0 284.0 0 270.0 243.0

243.0 259.0 269.0 0 247.0

256.0 254.0 243.0 247.0 0



#Experiments

As mentioned the algorithm should be running in quadratic time and space. This is firstly investigated for the algorithm doing pairwise global aligment with a linear gap cost (global_linear) and secondly for the algorithm doing pairwise global aligment with a affine gap cost (global_affine). 

A bash script was written that measure the time consumption for the algorithm. This bash script takes a number that defines how many times two predefined sequences(sequence 1 and sequence 2) are duplicated. These sequences are passed to to a command line that runs the main algortihm with the two sequences, and measures the time consumption of the algorithm. The bash script were run iterating through the values 1 to 10, measuring the time consumption of the algorithm for increasing n. (1 to 10 duplications of the original sequences)

```{bash, eval = F, echo = T, results = 'hide'}
./measureTime_global_alignment.sh 0 5 15 2> Output/times_linearCost.txt
./measureTime_global_alignment.sh 5 5 15 2> Output/times_affineCost.txt
```


```{r, eval=F, echo=FALSE}

times_linear <- read.table("Output/times_linearCost.txt")
Ns <- times_linear$V1[c(T,F)]
secs_linear <- times_linear$V1[c(F,T)]

times_affine <- read.table("Output/times_affineCost.txt")
secs_affine <- times_affine$V1[c(F,T)]
# Ns_affine <- times_affine$V1[c(T,F)]

timings <- data.frame(n = Ns, linear = secs_linear, affine = secs_affine)

time_plot <- ggplot(data=timings)+
  geom_point(aes(x=n,y=linear/n^2))+
  geom_line(aes(x=n,y=linear/n^2,color="darkblue"))+
  geom_point(aes(x=n,y=affine/n^2))+
  geom_line(aes(x=n,y=affine/n^2,color="red"))+
  ggtitle("Global aligment with linear and affine gap cost")+
  ylab("Seconds/N^2")+
  scale_color_discrete(name = "Gap costs", labels = c("Linear", "Affine"))

time_plot
```

As seen from the plot the algorithm does run in quadratic time as expected. Global alignment with linear gap cost seems pretty semilar to global aligment with affine gapcost. As the affine gap cost uses more matrices it makes sense that this version of the algorithm seems to take a little more time then the linear gap cost version when n becomes larger. Much larger numbers of n might elucidate the difference better.    











